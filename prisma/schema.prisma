// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
  directUrl= env("DIRECT_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String?
  role      String   @default("CLIENTE") // Ahora es String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchases Purchase[]
  sales     Sale[]

  // Un usuario puede tener un perfil de cliente asociado (1 a 0-1).
  // Este es el "lado inverso" de la relación, donde User declara que existe un Customer relacionado.
  customer  Customer? // Ya no necesitamos customerId String? aquí si la FK está en Customer

  @@map("users")
}

model Customer {
  id        String   @id @default(cuid())
  // Un perfil de cliente TIENE que estar asociado a un usuario (1 a 1 o 1:0-1).
  // La clave foránea 'userId' está aquí, en el modelo Customer, apuntando a User.
  // Es el "lado que posee" la relación, donde se definen 'fields' y 'references'.
  // onDelete: Cascade significa que si el User asociado se borra, este Customer también se borrará.
  userId    String   @unique @map("user_id") // Clave foránea al ID del User. Unique para relación 1:1.
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade) // Relación explícita con User

  name      String
  email     String   @unique
  phone     String?
  address   String?  @db.Text
  isWholesale Boolean @default(false) // Nuevo: Para identificar clientes mayoristas
  storeLocation String? @db.NVarChar(255) // Nuevo: Ubicación de la tienda para clientes mayoristas
  // ELIMINADO: loyaltyPoints Int    @default(0) // <--- ¡ESTO SE ELIMINA!

  isActive  Boolean  @default(true)
  registeredAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sales     Sale[]

  @@map("customers")
}

// ... (El resto de tus modelos Product, Supplier, Purchase, PurchaseItem, Sale, SaleItem) ...

model Product {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  price       Float
  stock       Int      @default(0)
  sku         String?  @unique
  imageUrl    String?  @db.Text
  category    String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  purchaseItems PurchaseItem[]
  saleItems     SaleItem[]

  @@map("products")
}

model Supplier {
  id        String   @id @default(cuid())
  name      String
  email     String?  @unique
  phone     String?
  address   String?  @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchases Purchase[]

  @@map("suppliers")
}

model Purchase {
  id         String   @id @default(cuid())
  supplierId String
  userId     String
  total      Float
  notes      String?  @db.Text
  status     String   @default("pending")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  supplier Supplier       @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  items    PurchaseItem[]

  @@map("purchases")
}

model PurchaseItem {
  id         String  @id @default(cuid())
  purchaseId String
  productId  String
  quantity   Int
  price      Float

  purchase Purchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@map("purchase_items")
}

model Sale {
  id         String   @id @default(cuid())
  userId     String
  customerId String?
  total      Float
  notes      String?  @db.Text
  status     String   @default("completed")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user     User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  customer Customer?  @relation(fields: [customerId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  items    SaleItem[]

  @@map("sales")
}

model SaleItem {
  id        String @id @default(cuid())
  saleId    String
  productId String
  quantity  Int
  price     Float

  sale    Sale    @relation(fields: [saleId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@map("sale_items")
}
// ... (Despues de todos tus otros modelos)

// === NUEVO MODELO PARA BITÁCORA/LOG ===
model ActivityLog {
  id        String   @id @default(cuid())
  userId    String?  // Quién realizó la acción (opcional)
  user      User?    @relation(fields: [userId], references: [id])
  action    String   // Descripción de la acción (ej. "Producto creado", "Venta registrada", "Stock actualizado")
  entityType String  // Tipo de entidad afectada (ej. "Product", "Sale", "Customer")
  entityId  String?  // ID de la entidad afectada (opcional)
  details   String?  @db.Text // Detalles adicionales en JSON o texto plano
  timestamp DateTime @default(now())

  @@map("activity_logs")
}